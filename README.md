## What is HTTP?  (Hyper Text Transfer Protocol)

HTTP is a stateless web protocol that allows server and client to communicate between each other.
Stateless means that HTTP doesn't remember what you did before. So, you have to introduce youself on each request.
Supposing a website that includes a few links inside. HTTP doesn't remember when you jump from one link to another.
More clear, each request is completely independent! So, the protocol never knows if a user is logged in,-
what there are in their shopping cart, etc.

Because of this case, we shouldn't lose user's information in sake of user experience on each request.
If we don't do that, a user have to log in on each request (clicking a link/button/etc)

HTTP requests and responses are sent in plaintext, which means that anyone can read them.
Most information that is sent over the Internet, including website content and API calls, uses the HTTP protocol. 
There are two main kinds of HTTP messages : 
<ol>
<li>Requests</li>
<li>Responses</li>
</ol>

### What is an HTTP request? What is an HTTP response?

HTTP requests are generated by a user's browser as the user interacts with web properties. For example, if a user clicks on a hyperlink, the browser will send a series of "HTTP GET" requests for the content that appears on that page. If someone Googles "What is HTTP?" and this article shows up in the search results, when they click on the link, their browser will create and send a series of HTTP requests in order to get the information necessary to render the page.

These HTTP requests all go to either an origin server or a proxy caching server, and that server will generate an HTTP response. 
HTTP responses are answers to HTTP requests.

### What does a typical HTTP request look like?

An HTTP request is just a series of lines of text that follow the HTTP protocol. 
A GET request might look like this  :

```javascript
GET /hello.txt HTTP/1.1
User-Agent: curl/7.63.0 libcurl/7.63.0 OpenSSL/1.1.l zlib/1.2.11
Host: www.example.com
Accept-Language: en
```

This section of text (above), generated by the user's browser, gets sent across the Internet. 
The problem is, it's sent just like this (above), in plaintext that anyone monitoring the connection can read.
This is especially an issue when users submit sensitive data via a website or a web application. 

This could be a password, a credit card number, or any other data entered into a form, and in HTTP all this data is sent-
in plaintext for anyone to read. 
When a user submits a form, the browser translates this into an HTTP POST request instead of an HTTP GET request.

When an origin server receives an HTTP request, it sends an HTTP response, which is similar :
```javascript

HTTP/1.1 200 OK
Date: Wed, 30 Jan 2019 12:14:39 GMT
Server: Apache
Last-Modified: Mon, 28 Jan 2019 11:17:01 GMT
Accept-Ranges: bytes
Content-Length: 12
Vary: Accept-Encoding
Content-Type: text/plain
```

If a website uses HTTP instead of HTTPS, all requests and responses can be read by anyone who is monitoring the session. 
Essentially, a malicious actor can just read the text in the request or the response and know exactly what information someone-
is asking for, sending, or receiving.

## What is HTTPS?

The S in HTTPS stands for "secure." HTTPS uses TLS (or SSL) to encrypt HTTP requests and responses, so in the example above, instead of the text, an attacker would see a bunch of seemingly random characters.

Instead of  :
```javascript
GET /hello.txt HTTP/1.1
User-Agent: curl/7.63.0 libcurl/7.63.0 OpenSSL/1.1.l zlib/1.2.11
Host: www.example.com
Accept-Language: en
```
The attacker sees something like  :

<code><b>t8Fw6T8UV81pQfyhDkhebbz7+oiwldr1j2gHBB3L3RFTRsQCpaSnSBZ78Vme+DpDVJPvZdZUZHpzbbcqmSW1+3xXGsERHg9YDmpYk0VVDiRvw1H5miNieJeJ/FNUjgH0BmVRWII6+T4MnDwmCMZUI/orxP3HGwYCSIvyzS3MpmmSe4iaWKCOHQ==</b></code>

## CORS ( Cross-Origin Resource Sharing)
<ul>
<li>
  CORS is a security feature implemented by web browsers to prevent unauthorized access to resources hosted on different
  domains (origin). It is an important aspect of web application security that helps protect users from potential attacks.
</li>
<li>
  In the context of web development, an "origin" is a combination of the protocol (e.g., http, https, udp),-
  domain (e.g. example.com), and port (e.g., 80, 443, 8080) from which a web page is served.
</li>
<li>
  Browsers enforce the Same-Origin Policy (SOP), which restricts web pages from making requests to a different origin-
  than the one that served the page.
</li> 
<li>
  This policy helps prevent various security risks, such as unauthorized data access and-
  cross-site request forgery (CSRF) attacks.
</li>
<li>
  However, there are legitimate scenarios where web pages from one origin may need to access resources hosted on another-
  origin. For example, an application hosted on https://app.example.com may need to request data-
  from an API hosted on https://api.example.com. 
</li>
<li>
  CORS allows servers to specify which origins are permitted to access their resources, effectively-
  relaxing the Same-Origin Policy for those trusted origins. (whitelist)
</li>
</ul>

### Here's how CORS works

<ol>
<li>
  Origin Header: When a web page makes a cross-origin request (e.g., using JavaScript's XMLHttpRequest or-
  Fetch API), the browser includes an Origin header in the request (req.headers.origin),-
  indicating the origin of the requesting web page. (e.g https://www.google.com <-- origin)
</li>
<li>
  Pre-flight Request: For certain types of requests (e.g., requests with certain HTTP methods like PUT or DELETE,-
  or requests with custom headers), the browser first sends a pre-flight request with the HTTP OPTIONS method-
  to the target server.  
  This pre-flight request asks the server if the actual request is allowed from the given origin.
</li>
<li>
  CORS Headers: The server responds to the pre-flight request with CORS-specific response headers,-
  such as Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers, and others.
  These headers inform the browser about the permissions granted to the requesting origin.
</li>
<li>
  Actual Request: If the server confirms that the requesting origin is allowed, the actual request is made.
  The server includes the appropriate CORS headers in the response to the actual request, allowing the browser-
  to determine whether the response should be accessible to the requesting page.
</li>
</ol>
<ul>
  <li>
    CORS is essential for secure cross-origin communication in modern web applications while still-
    maintaining the protection provided by the Same-Origin Policy. 
  </li>
  <li>
    It is up to web developers to configure their server to include the appropriate CORS headers based on-
    their security requirements and the origins they want to allow access to their resources.
  </li>
</ul>

## MIDDLEWARES

* Middleware functions in Express.js are functions that have access to the request (req) and response (res) objects,-
and they can perform various tasks on the request or response, modify them,-
or pass control to the "next" middleware (third argument) in the chain.

* There are three type middlewares ;
1. built-in
2. custom
3. third-party

* We use <code>app.use(  middleware )</code> method while using middleware
* Middlewares are applied all over the app, when we set it.
* If we write our custom middleware, we have to put it on top of all the routes. So, the order is important!
* <code>app.use( express.urlencoded({options}) )</code> is a middleware function used to handle URL-encoded data in HTTP POST-
  requests. It is part of the body-parser middleware package, which allows Express to parse incoming request bodies.
  When a client sends data using the application/x-www-form-urlencoded content type (commonly used in HTML forms), the-
  server needs to extract and parse that data to access it easily in the route handlers.
* <code>app.use( express.json() )</code> handles files coming in type of json. Its content-type is 'application/json'
* <code>app.use( express.static( path) )</code> allows us to define our static file. (e.g express.static(./public) )
* Thanks to express.static, we can separate out html files to another folders. They will run as they are in public-
  directory whatever they have links.</br>
  (e.g The img tag in another file, but it'll work --> <code>src="./imgs/img_01.jpg"</code>)

<b>NOTE</b> : If we don't use express.static middleware, we will have to create another GET request method for our images,css,etc. It's because browser requests for each file (css, images, etc) even for favico.ico

## BCRYPT

  * Provides password hashing and comparison functionalities using the bcrypt hashing algorithm. 
  * It's commonly used to securely store passwords in databases, protecting user credentials from being-
    easily compromised in the event of a data breach.

  * bcrypt uses a variant of the Blowfish encryption algorithm with a technique called-
    key stretching, which makes it computationally expensive and time-consuming to generate hashes.
  * This is a desirable feature because it increases the difficulty for attackers attempting-
    to crack hashed passwords through brute-force or dictionary attacks.

  * To hash a password with bcrypt, you typically follow these steps  :
    1. Generate a random salt  : 
        * A salt is a random value used to add additional entropy to the hashing process.
        * It ensures that even users with the same passwords will have different hashes.

    2. Hash the password with the generated salt and a specified number of rounds :
        * bcrypt allows you to configure the number of "salt rounds" or iterations used during the hashing process. 
        * More rounds make the computation slower and increase the security.

    3. Store the generated hash and salt securely in your database.

  * When verifying a password, bcrypt automatically extracts the salt from the stored hash and uses it to rehash-
  the provided password. If the newly generated hash matches the one stored in the database, the password is-
  considered valid.

<em><b>NOTE</b></em> : bcrypt recommeds you to always use async functions. But it includes sync versions of its methods.

### Here's a basic example of using bcrypt :
```javascript
const bcrypt = require('bcrypt');
const userPassw = 'mySecurePassword';

// Generating a salt and hashing the password
bcrypt.hash(userPassw, 10, function(err, hash) {
  if (err) {
    console.error('Error hashing password:', err);
  } else {
    // Store the 'hash' value securely in your database along with the salt
    console.log('Hashed password:', hash);
  }
});

// Verifying a password
const storedHash = '...'; // Retrieve the hashed password from your database
bcrypt.compare(userPassw, storedHash, function(err, isMatch) {
  if (err) {
    console.error('Error comparing passwords:', err);
  } else {
    if (isMatch) {
      console.log('Password is correct!');
    } else {
      console.log('Password is incorrect!');
    }
  }
});
```
<em><b>NOTE :</em></b>  Callback is optional.

#### A Note on Rounds

* rounds=8 : ~40 hashes/sec
* rounds=9 : ~20 hashes/sec
* rounds=10: ~10 hashes/sec
* rounds=11: ~5  hashes/sec
* rounds=12: 2-3 hashes/sec
* rounds=13: ~1 sec/hash
* rounds=14: ~1.5 sec/hash
* rounds=15: ~3 sec/hash
* rounds=25: ~1 hour/hash
* rounds=31: 2-3 days/hash

### JWT (JSON WEB TOKEN)

* JWT is a compact and self-contained way of transmitting information between parties as a JSON object.
* It is commonly used to authenticate users and share information securely between different components of an application. 

* Let's dive into the key aspects of JWT  :
    A JWT consists of three parts, separated by dots (.). These parts are base64-encoded JSON objects.
1. <b>Header</b> : Contains information about the algorithm used for signature generation.
It typically looks like this  :

```javascript
    {
      "alg": "HS256",
      "typ": "JWT"
    }
```

  2. <b>Payload</b> : Contains the claims or information about the entity (user, system, etc.) and additional data.<br/>
      It includes three types of claims :

      1. Registered Claims: These are a set of predefined claims with standardized meanings, like "iss" (issuer),
        "exp" (expiration time), "sub" (subject), "aud" (audience), etc.
      * Public Claims: Custom claims that can be defined by the parties involved, but should be used carefully
        to avoid collisions.
      * Private Claims: Custom claims that are meant to be agreed upon between parties and should not be
        publicly registered to avoid conflicts.

        * Signature : The signature is generated by encoding the header and payload together along with a secret
          key using the algorithm specified in the header. 
          The signature ensures the integrity of the token and verifies that it hasn't been tampered with.

      2. Token Creation and Flow : When a user logs in or performs an authentication action, the server-
          generates a JWT and sends it back to the client. 
          The client then typically stores the token, usually in local storage or a cookie.
          Subsequently, the client includes the JWT in the "Authorization" header of HTTP requests to-
          the server to access protected resources. 
          The server then verifies the token's integrity and authenticity using the secret key-
          and validates the claims.

      3. Statelessness : One of the key advantages of JWT is that it allows for stateless authentication.
          The server doesn't need to store any session information since all the necessary data is contained-
          within the token itself. This simplifies the server-side architecture and can be beneficial-
          in a distributed environment.

      4. Security Considerations:

        * Token Expiration: JWTs typically have an expiration time (the "exp" claim) to limit their-
          lifespan and reduce the risk of unauthorized access.

        * Token Scope: Ensure that the token contains only the necessary information. 
          Avoid including sensitive data in the payload since JWTs are easily readable (though base64-encoded)
          by anyone with access to them.

        * Secure Transmission: Always use HTTPS to transmit JWTs to prevent eavesdropping and-
          man-in-the-middle attacks.

        * Validation and Verification: Employ strong algorithms and keys for token generation and verification.
          Commonly used algorithms include HMAC SHA-256 (HS256) and RSA.

        * Revocation: JWTs are immutable once issued. If you need the ability to revoke tokens-
          before their expiration, consider using a token blacklist or short-lived tokens.

#### ACCESS TOKEN VS REFRESH TOKEN

  1. <b>Access Token</b>  : 
      * An access token is a short-lived token that represents the user's identity and permissions.
        is used to access protected resources on the server.

      * When a user logs in or authenticates, the server issues an access token to the client (usually a web browser-
        or mobile app). The access token is typically a JWT containing relevant information about the user and their-
        permissions (claims).

      * The access token is included in the "Authorization" header of HTTP requests when accessing protected APIs-
        or resources on the server.

      * Access tokens have a limited lifespan, typically ranging from a few minutes to an hour, depending-
        on the application's security requirements.

      * Since access tokens are short-lived, they reduce the window of opportunity for an attacker-
        to misuse a stolen token.

      * If an access token expires, the client must request a new one using a refresh token (if available) or-
        by re-authenticating.

  2. <b>Refresh Token</b> : 
      * A refresh token is a long-lived token that is used to obtain a new access-
        token without requiring the user to re-enter their credentials (username and password). *!*

      * When the user initially logs in or grants permissions to the application, the server issues-
        both an access token and a refresh token. 
    
      * The refresh token is often more securely stored than the access token, such as in an HTTP-only cookie-
        or a secure storage mechanism.

      * When the access token expires, the client can use the refresh token to request a new access token-
        from the server without prompting the user to log in again. 
        This process is called token refresh or silent authentication.

      * Refresh tokens typically have a longer lifespan compared to access tokens, often ranging-
        from days to months, depending on the application's security policies.

      * It's essential to secure refresh tokens properly since they grant extended access to a user's account.
        Proper storage and transmission (e.g., HTTPS) are crucial to prevent token leakage and misuse.

#### Token Refresh Flow:

  1. When the access token is about to expire or is already expired, the client sends a request to the server,-
     including the refresh token.

  2. The server verifies the refresh token's validity, checks if the user is still authenticated,-
     and grants a new access token if everything is valid.

  3. If the refresh token has also expired or becomes invalid for any reason, the client will-
     need to request the user to re-authenticate.

#### Some methods :

* jwt.sign is used to create a JSON Web Token (JWT). 
* It takes a payload, a secret key or private key, and optionally some additional options as input,-
  and produces a signed JWT as output.

* Payload (data)  : The payload is the data or claims that you want to include in the JWT.
  It can be any valid JSON data, and it typically contains information about the user or other relevant data.
  The payload is usually an object, but some libraries might accept a string or buffer as well.

* Secret Key (or Private Key): The secret key (or private key in the case of asymmetric algorithms)-
  is a piece of confidential information known only to the server that will be used to sign the JWT.
  The signature ensures that the token has not been tampered with since it was signed.

* Options (Optional): The jwt.sign method often accepts additional options that allow you to customize
  the behavior of the token generation. Some common options include :

    * algorithm: The algorithm used to create the signature, such as "HS256" for HMAC SHA-256 or-
      "RS256" for- RSA SHA-256.

    * expiresIn or expiresAt: The expiration time or duration after which the token will be considered invalid.
      This can be specified as a number of seconds or as a specific date and time.
    *  issuer (iss): The issuer of the token, indicating which entity issued the JWT.
    *  subject (sub): The subject of the token, representing the user or entity the token belongs to.
    *  audience (aud): The audience of the token, specifying the recipients or intended recipients of the JWT.

```javascript
const jwt = require('jsonwebtoken');

const payload = { user_id: 123, role: 'admin' };
const secretKey = 'your_secret_key';    // A Tip : crypto.randomBytes(64).toString('hex')

const options = { expiresIn: '1h', issuer: 'your_app_name' };

const token = jwt.sign(payload, secretKey, options);
console.log(token);
```

**NOTE :** Keep in mind that the jwt.sign method should be used in a secure environment, and the secret key-
  should be kept confidential to prevent unauthorized access or tampering of the tokens. 
  Also, ensure that you use appropriate and secure algorithms for signing the tokens-
  based on your application's security requirements.


// What is a Cookie?

  //* A cookie is a small piece of data that a website stores on a user's web browser. 
  //* It is used to remember information about the user or their browsing behavior. 
  //* Cookies are commonly used to enhance user experiences, remember login information, track user preferences,-
  //  and perform other tasks that improve website functionality.

  // Common Cookie Attributes

    // 1- httpOnly: (boolean)

      // The httpOnly attribute is a flag that can be set on a cookie. 
      // When this flag is present, it means that the cookie is not accessible to JavaScript running in the browser. 
      // It's a security measure to prevent certain types of cross-site scripting (XSS) attacks.
      // XSS attacks attempt to steal information from cookies by injecting malicious scripts into a website.

      // By setting the httpOnly flag, the cookie can only be accessed by the server, which helps protect-
      // sensitive data from being stolen by malicious scripts running in the user's browser.

    // 2- sameSite:

      // The sameSite attribute is another flag that can be set on a cookie. 
      // It controls when and how the cookie is sent by the browser to the server. 
      // The sameSite attribute is used to prevent certain cross-site request forgery (CSRF) attacks.

      //* There are three possible values for the sameSite attribute  :

        // 1- SameSite = None : The cookie will be sent in cross-origin requests (e.g., requests from one domain to another)-
        // as long as they are made with a safe HTTP method (e.g., GET). 
        // This is often used for third-party cookies used by services embedded on different-
        // websites. (e.g, to log in another website through you google account)

        // 2- SameSite = Lax : The cookie will be sent in cross-origin requests made with a "top-level" navigation-
        // (e.g., clicking on a link) but not for requests that result from loading resources-
        // (e.g., images, scripts) from another site. This provides some protection against CSRF attacks.

        // 3- SameSite = Strict : The cookie will only be sent in requests that originate from the same site-
        // (same-site requests). It will not be sent in cross-origin requests, providing the highest level of CSRF protection.

  //* CSRF (Cross-Site Request Forgery) :

    //- CSRF is a type of attack where a malicious website tricks a user's web browser into making an unintended-
    //  request to another website where the user is authenticated. 
    //- If the user is logged in to the target website, the malicious request may perform actions-
    //  on their behalf without their knowledge or consent.

    //* To prevent CSRF attacks, websites can use techniques like CSRF tokens and the sameSite attribute on cookies.
    //* The sameSite attribute ensures that cookies are not sent in cross-origin requests, thereby reducing-
    //  the risk of unauthorized requests.

// NOTE : 
  // Why are them all required? Because HTTP protocol is stateless. So, we have to introduce outselves on each request.
